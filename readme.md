[3414. 校门外的树 - AcWing题库](https://www.acwing.com/problem/content/3417/)

1. 如果 T≠∅T≠∅，T∩{al,al+1,⋯,ar}=∅T∩{al,al+1,⋯,ar}=∅，并且存在一个公差 d≥1d≥1，使得 T∪{al,ar}T∪{al,ar} 中的元素按照从小到大的顺序排序后，可以构成一个公差为 dd 的等差数列（显然，这个等差数列的首项为 alal，末项为 arar），则 TT 在 [al,ar)[al,ar) 上是美观的；
2. 如果 T∩{al,al+1,⋯,ar}=∅T∩{al,al+1,⋯,ar}=∅，并且存在一个下标 mm（l<m<rl<m<r），使得 T∩(al,am)T∩(al,am) 在 [al,am)[al,am) 上是美观的，且 T∩(am,ar)T∩(am,ar) 在 [am,ar)[am,ar) 上是美观的，则 TT 在 [al,ar)[al,ar) 上是美观的。

类比这道dp：

​	将a[1]..a[n]划分为任意段，使得每段的和位于[a,b]，统计方案数

在这道题中：

​	每两个障碍物之间的一个区间就是一个a[i], 求满足条件的a[1]...a[n]的一个方案数

​	也就是说这样左端点固定就是a[1]了，dp 的框架为

```c
f[i]//前i个区间一共的方案数
f[i] = f[k - 1] * (a[k]..a[i])的方案数
```

注意，这里a[k]..a[i]的方案数指的是条件1，也就是一个**原子区间 (d不变）**的方案数

如果a[k]..a[i]能够$O(logm)$转移，那么整体的复杂度就是$O(n^2logm)$ $m$是最大的区间长度



可以通过$O(1)$转移

假如一个原子区间由a[l],a[l+1],...a[r]构成

则满足条件的每一个种树方案，它的 $d$ 必定满足一下3个条件
$$
1.d\mid\sum_{i=l}^{r}a[i]\\
2.d\nmid\sum_{i=l}^{k}a[i],l<k<r\\
3.d\nmid\sum_{i=k}^{r}a[i],l<k<r\\
$$
可以很明显发现，若2满足则3也满足，反之亦然

**所以我们只要满足1,3两个条件**

由1,3两个条件，我们可以得出，假如已经知道了满足$a[k, i]$的所有$d_{k,i}$ ,那么 $a[k-1, i]$ 的所有 $d_{k-1,i}$ 必定不等于 $d_{k, i}$, $d_{k+1, i}...,d_{i-1,i}$

否则与3矛盾

$k$从大到小转移，枚举 $$\sum_{k}^{i}a$$ 的所有约数 $d$, 并且 $d$ 不能和之前枚举的 $d$ 相同



[1,n]每个数的约数总和只有$O(nlogn)$个，所以平摊每个数的约数个数是$log(n)$

所以总的复杂度是$O(n^2log(m))$

要预处理出每个数的所有约数（不包括它自己）

```c++
    vector<vector<int>> divList;
    divList.resize(a[n] + 1);
    for(int i = 1; i <= a[n]; i++){
        for(int j = 2 * i; j <= a[n]; j += i){
            divList[j].push_back(i);
        }
    }
```



[3300. 食材运输 - AcWing题库](https://www.acwing.com/problem/content/description/3303/)

## 题意：

一棵树，边有权值，k辆车最多从m个点出发，$m<=k$ ,每辆车指定需要送的点集，求车路程的最小值。

## 分析：

### 1.一辆车从某个点出发的最小值：

设路径树为从跟出发到需要送的点的路径构成的树，显然 路径树 $\subset$ 树

路径树的生成可以用递归生成：

> 对 $\forall$ 节点 $u$， 及它的孩子 $v$
>
> 若$v$ 为需要送的点，或 $v$ 的子树中有需要送的点，
>
> 则 $uv$ $\in$ 路径树

```
路程最小值 = 路径树的边权和*2 - 路径树根节点到叶节点的最大距离
```

路径最小值可以用归纳法证明，不再展开



### 2.二分枚举最终答案，判定答案是否可以

对于每一次枚举，得到能够从点 $u$ 出发的车的集合 $C_u$， $C_u$ 中的每辆车都满足从 $u$  出发路程的最小值小于等于枚举的答案。

有 $n$ 个点就有 $n$ 个不同的集合，现在要判定从中最多选 $m$ 个集合， 这 $m$ 个集合的并集能否覆盖所有车辆。

这个是**集合覆盖**问题， 是NPC的，但是用动态规划可以在伪多项式内解决。



### 3.集合覆盖问题

转化一下问题，从判定问题变为优化的问题，即要覆盖所有车辆最少需要选多少个集合。

令$f[i][j]$ 表示前 $i$ 个集合 覆盖了 $j$ 的二进制表示的车辆的状态最少需要选多少个集合



考虑第 $i+1$ 个集合，如果不选它，那么 $f[i+1][j] =f[i][j]$

如果选他，那么 $j$ 状态就会变为 $j | C_{i+1}$  状态。

注意**这个转移是多对一的关系**，即有多个 $f[i][j]$ 会映射到同一个 $f[i + 1][k]$,  取最小值。因此转移的时候应该枚举从$i$ 转移到 $i +1$，而不是枚举 $i+1$ 能从哪些 $i$ 转移过来



空间上可以状态压缩把  $i$ 压缩掉，注意由于 $j | C_{i+1}$  是单调非减的，所以转移要倒着转移。**这跟 带权值的背包问题的压缩 是一样的**



```c++
    For(i, 1, n){
        for(int j = (1 << k) - 1; j >= 0; j--){
            f[j | canRun[i]] = min(f[j | canRun[i]], f[j] + 1);
        }
    }
```

[4008. 脉冲神经网络 - AcWing题库](https://www.acwing.com/problem/content/description/4011/)

最后30分要降低复杂度，做常数优化。

用堆实现的复杂度是$O(T*(N+P)*log(S))$

用滚动数组实现的复杂度是 $O(T*(N+P))$

[3412. 邻域均值 - AcWing题库](https://www.acwing.com/problem/content/3415/)

二位前缀和及二维部分和

$s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]$

$\sum_{i=li}^{i=ri}\sum_{j=lj}^{j=rj}a[i][j] = s[ri][rj] - s[ri][lj-1] - s[li -1][rj] + s[li-1][lj-1]$

时间、空间复杂度$O(n^2)$



[3290. 1246 - AcWing题库](https://www.acwing.com/problem/content/3293/)

考虑串的位数$<=2$，此时可以得出如下生成转移

https://box.nju.edu.cn/f/c07a264e6f2243f69174/?dl=1

要么转移的下一个数由一个数字生成，要么由两个数字生成，中间拼接而成。

就可以形成递推式。

通过矩阵乘法可以在$log$ 的时间内计算出答案。

原理见

https://box.nju.edu.cn/f/c07a264e6f2243f69174/?dl=1

超过2位的可以通过模式匹配到2位，见demo中做法
